// --- env.h ---

using shaderc_target_env = enum {
  shaderc_target_env_vulkan,  // SPIR-V under Vulkan semantics
  shaderc_target_env_opengl,  // SPIR-V under OpenGL semantics
  // NOTE: SPIR-V code generation is not supported for shaders under OpenGL
  // compatibility profile.
  shaderc_target_env_opengl_compat,  // SPIR-V under OpenGL semantics,
                                     // including compatibility profile
                                     // functions
  shaderc_target_env_webgpu,         // Deprecated, SPIR-V under WebGPU
                                     // semantics
  shaderc_target_env_default = shaderc_target_env_vulkan
};

using shaderc_env_version = uint32_t;

#defineAs int shaderc_env_version_vulkan_1_0 ((1 << 22))
#defineAs int shaderc_env_version_vulkan_1_1 ((1 << 22) | (1 << 12))
#defineAs int shaderc_env_version_vulkan_1_2 ((1 << 22) | (2 << 12))
#defineAs int shaderc_env_version_vulkan_1_3 ((1 << 22) | (3 << 12))
#defineAs int shaderc_env_version_vulkan_1_4 ((1 << 22) | (4 << 12))
#defineAs int shaderc_env_version_opengl_4_5 450
// Deprecated, WebGPU env never defined versions
#defineAs int shaderc_env_version_webgpu 451

// The known versions of SPIR-V.
using shaderc_spirv_version = enum {
  // Use the values used for word 1 of a SPIR-V binary:
  // - bits 24 to 31: zero
  // - bits 16 to 23: major version number
  // - bits 8 to 15: minor version number
  // - bits 0 to 7: zero
  shaderc_spirv_version_1_0 = 0x010000,
  shaderc_spirv_version_1_1 = 0x010100,
  shaderc_spirv_version_1_2 = 0x010200,
  shaderc_spirv_version_1_3 = 0x010300,
  shaderc_spirv_version_1_4 = 0x010400,
  shaderc_spirv_version_1_5 = 0x010500,
  shaderc_spirv_version_1_6 = 0x010600
};

// --- status.h ---

// Indicate the status of a compilation.
using shaderc_compilation_status = enum {
  shaderc_compilation_status_success = 0,
  shaderc_compilation_status_invalid_stage = 1,  // error stage deduction
  shaderc_compilation_status_compilation_error = 2,
  shaderc_compilation_status_internal_error = 3,  // unexpected failure
  shaderc_compilation_status_null_result_object = 4,
  shaderc_compilation_status_invalid_assembly = 5,
  shaderc_compilation_status_validation_error = 6,
  shaderc_compilation_status_transformation_error = 7,
  shaderc_compilation_status_configuration_error = 8,
};

// --- shaderc.h ---

// Source language kind.
using shaderc_source_language = enum {
  shaderc_source_language_glsl,
  shaderc_source_language_hlsl,
};

using shaderc_shader_kind = enum {
  // Forced shader kinds. These shader kinds force the compiler to compile the
  // source code as the specified kind of shader.
  shaderc_vertex_shader,
  shaderc_fragment_shader,
  shaderc_compute_shader,
  shaderc_geometry_shader,
  shaderc_tess_control_shader,
  shaderc_tess_evaluation_shader,

  shaderc_glsl_vertex_shader = shaderc_vertex_shader,
  shaderc_glsl_fragment_shader = shaderc_fragment_shader,
  shaderc_glsl_compute_shader = shaderc_compute_shader,
  shaderc_glsl_geometry_shader = shaderc_geometry_shader,
  shaderc_glsl_tess_control_shader = shaderc_tess_control_shader,
  shaderc_glsl_tess_evaluation_shader = shaderc_tess_evaluation_shader,

  // Deduce the shader kind from #pragma annotation in the source code. Compiler
  // will emit error if #pragma annotation is not found.
  shaderc_glsl_infer_from_source,
  // Default shader kinds. Compiler will fall back to compile the source code as
  // the specified kind of shader when #pragma annotation is not found in the
  // source code.
  shaderc_glsl_default_vertex_shader,
  shaderc_glsl_default_fragment_shader,
  shaderc_glsl_default_compute_shader,
  shaderc_glsl_default_geometry_shader,
  shaderc_glsl_default_tess_control_shader,
  shaderc_glsl_default_tess_evaluation_shader,
  shaderc_spirv_assembly,
  shaderc_raygen_shader,
  shaderc_anyhit_shader,
  shaderc_closesthit_shader,
  shaderc_miss_shader,
  shaderc_intersection_shader,
  shaderc_callable_shader,
  shaderc_glsl_raygen_shader = shaderc_raygen_shader,
  shaderc_glsl_anyhit_shader = shaderc_anyhit_shader,
  shaderc_glsl_closesthit_shader = shaderc_closesthit_shader,
  shaderc_glsl_miss_shader = shaderc_miss_shader,
  shaderc_glsl_intersection_shader = shaderc_intersection_shader,
  shaderc_glsl_callable_shader = shaderc_callable_shader,
  shaderc_glsl_default_raygen_shader,
  shaderc_glsl_default_anyhit_shader,
  shaderc_glsl_default_closesthit_shader,
  shaderc_glsl_default_miss_shader,
  shaderc_glsl_default_intersection_shader,
  shaderc_glsl_default_callable_shader,
  shaderc_task_shader,
  shaderc_mesh_shader,
  shaderc_glsl_task_shader = shaderc_task_shader,
  shaderc_glsl_mesh_shader = shaderc_mesh_shader,
  shaderc_glsl_default_task_shader,
  shaderc_glsl_default_mesh_shader,
};

using shaderc_profile = enum {
  shaderc_profile_none,  // Used if and only if GLSL version did not specify
                         // profiles.
  shaderc_profile_core,
  shaderc_profile_compatibility,  // Disabled. This generates an error
  shaderc_profile_es,
};

// Optimization level.
using shaderc_optimization_level = enum {
  shaderc_optimization_level_zero,  // no optimization
  shaderc_optimization_level_size,  // optimize towards reducing code size
  shaderc_optimization_level_performance,  // optimize towards performance
};

// Resource limits.
using shaderc_limit = enum {
  shaderc_limit_max_lights,
  shaderc_limit_max_clip_planes,
  shaderc_limit_max_texture_units,
  shaderc_limit_max_texture_coords,
  shaderc_limit_max_vertex_attribs,
  shaderc_limit_max_vertex_uniform_components,
  shaderc_limit_max_varying_floats,
  shaderc_limit_max_vertex_texture_image_units,
  shaderc_limit_max_combined_texture_image_units,
  shaderc_limit_max_texture_image_units,
  shaderc_limit_max_fragment_uniform_components,
  shaderc_limit_max_draw_buffers,
  shaderc_limit_max_vertex_uniform_vectors,
  shaderc_limit_max_varying_vectors,
  shaderc_limit_max_fragment_uniform_vectors,
  shaderc_limit_max_vertex_output_vectors,
  shaderc_limit_max_fragment_input_vectors,
  shaderc_limit_min_program_texel_offset,
  shaderc_limit_max_program_texel_offset,
  shaderc_limit_max_clip_distances,
  shaderc_limit_max_compute_work_group_count_x,
  shaderc_limit_max_compute_work_group_count_y,
  shaderc_limit_max_compute_work_group_count_z,
  shaderc_limit_max_compute_work_group_size_x,
  shaderc_limit_max_compute_work_group_size_y,
  shaderc_limit_max_compute_work_group_size_z,
  shaderc_limit_max_compute_uniform_components,
  shaderc_limit_max_compute_texture_image_units,
  shaderc_limit_max_compute_image_uniforms,
  shaderc_limit_max_compute_atomic_counters,
  shaderc_limit_max_compute_atomic_counter_buffers,
  shaderc_limit_max_varying_components,
  shaderc_limit_max_vertex_output_components,
  shaderc_limit_max_geometry_input_components,
  shaderc_limit_max_geometry_output_components,
  shaderc_limit_max_fragment_input_components,
  shaderc_limit_max_image_units,
  shaderc_limit_max_combined_image_units_and_fragment_outputs,
  shaderc_limit_max_combined_shader_output_resources,
  shaderc_limit_max_image_samples,
  shaderc_limit_max_vertex_image_uniforms,
  shaderc_limit_max_tess_control_image_uniforms,
  shaderc_limit_max_tess_evaluation_image_uniforms,
  shaderc_limit_max_geometry_image_uniforms,
  shaderc_limit_max_fragment_image_uniforms,
  shaderc_limit_max_combined_image_uniforms,
  shaderc_limit_max_geometry_texture_image_units,
  shaderc_limit_max_geometry_output_vertices,
  shaderc_limit_max_geometry_total_output_components,
  shaderc_limit_max_geometry_uniform_components,
  shaderc_limit_max_geometry_varying_components,
  shaderc_limit_max_tess_control_input_components,
  shaderc_limit_max_tess_control_output_components,
  shaderc_limit_max_tess_control_texture_image_units,
  shaderc_limit_max_tess_control_uniform_components,
  shaderc_limit_max_tess_control_total_output_components,
  shaderc_limit_max_tess_evaluation_input_components,
  shaderc_limit_max_tess_evaluation_output_components,
  shaderc_limit_max_tess_evaluation_texture_image_units,
  shaderc_limit_max_tess_evaluation_uniform_components,
  shaderc_limit_max_tess_patch_components,
  shaderc_limit_max_patch_vertices,
  shaderc_limit_max_tess_gen_level,
  shaderc_limit_max_viewports,
  shaderc_limit_max_vertex_atomic_counters,
  shaderc_limit_max_tess_control_atomic_counters,
  shaderc_limit_max_tess_evaluation_atomic_counters,
  shaderc_limit_max_geometry_atomic_counters,
  shaderc_limit_max_fragment_atomic_counters,
  shaderc_limit_max_combined_atomic_counters,
  shaderc_limit_max_atomic_counter_bindings,
  shaderc_limit_max_vertex_atomic_counter_buffers,
  shaderc_limit_max_tess_control_atomic_counter_buffers,
  shaderc_limit_max_tess_evaluation_atomic_counter_buffers,
  shaderc_limit_max_geometry_atomic_counter_buffers,
  shaderc_limit_max_fragment_atomic_counter_buffers,
  shaderc_limit_max_combined_atomic_counter_buffers,
  shaderc_limit_max_atomic_counter_buffer_size,
  shaderc_limit_max_transform_feedback_buffers,
  shaderc_limit_max_transform_feedback_interleaved_components,
  shaderc_limit_max_cull_distances,
  shaderc_limit_max_combined_clip_and_cull_distances,
  shaderc_limit_max_samples,
  shaderc_limit_max_mesh_output_vertices_nv,
  shaderc_limit_max_mesh_output_primitives_nv,
  shaderc_limit_max_mesh_work_group_size_x_nv,
  shaderc_limit_max_mesh_work_group_size_y_nv,
  shaderc_limit_max_mesh_work_group_size_z_nv,
  shaderc_limit_max_task_work_group_size_x_nv,
  shaderc_limit_max_task_work_group_size_y_nv,
  shaderc_limit_max_task_work_group_size_z_nv,
  shaderc_limit_max_mesh_view_count_nv,
  shaderc_limit_max_mesh_output_vertices_ext,
  shaderc_limit_max_mesh_output_primitives_ext,
  shaderc_limit_max_mesh_work_group_size_x_ext,
  shaderc_limit_max_mesh_work_group_size_y_ext,
  shaderc_limit_max_mesh_work_group_size_z_ext,
  shaderc_limit_max_task_work_group_size_x_ext,
  shaderc_limit_max_task_work_group_size_y_ext,
  shaderc_limit_max_task_work_group_size_z_ext,
  shaderc_limit_max_mesh_view_count_ext,
  shaderc_limit_max_dual_source_draw_buffers_ext,
};

// Uniform resource kinds.
// In Vulkan, uniform resources are bound to the pipeline via descriptors
// with numbered bindings and sets.
using shaderc_uniform_kind = enum {
  // Image and image buffer.
  shaderc_uniform_kind_image,
  // Pure sampler.
  shaderc_uniform_kind_sampler,
  // Sampled texture in GLSL, and Shader Resource View in HLSL.
  shaderc_uniform_kind_texture,
  // Uniform Buffer Object (UBO) in GLSL.  Cbuffer in HLSL.
  shaderc_uniform_kind_buffer,
  // Shader Storage Buffer Object (SSBO) in GLSL.
  shaderc_uniform_kind_storage_buffer,
  // Unordered Access View, in HLSL.  (Writable storage image or storage
  // buffer.)
  shaderc_uniform_kind_unordered_access_view,
};

using shaderc_compiler_t = struct shaderc_compiler*;
fn shaderc_compiler_t shaderc_compiler_initialize();
fn void shaderc_compiler_release(shaderc_compiler_t compiler);

using shaderc_compile_options_t = struct shaderc_compile_options*;
fn shaderc_compile_options_t
    shaderc_compile_options_initialize();
fn shaderc_compile_options_t shaderc_compile_options_clone(
    const shaderc_compile_options_t options);
fn void shaderc_compile_options_release(
    shaderc_compile_options_t options);
fn void shaderc_compile_options_add_macro_definition(
    shaderc_compile_options_t options, const char* name, size_t name_length,
    const char* value, size_t value_length);
fn void shaderc_compile_options_set_source_language(
    shaderc_compile_options_t options, shaderc_source_language lang);
fn void shaderc_compile_options_set_generate_debug_info(
    shaderc_compile_options_t options);
fn void shaderc_compile_options_set_optimization_level(
    shaderc_compile_options_t options, shaderc_optimization_level level);
fn void shaderc_compile_options_set_forced_version_profile(
    shaderc_compile_options_t options, int version, shaderc_profile profile);

// An include result.
using shaderc_include_result = struct ShadercIncludeResult {
  // The name of the source file.  The name should be fully resolved
  // in the sense that it should be a unique name in the context of the
  // includer.  For example, if the includer maps source names to files in
  // a filesystem, then this name should be the absolute path of the file.
  // For a failed inclusion, this string is empty.
  const char* source_name;
  size_t source_name_length;
  // The text contents of the source file in the normal case.
  // For a failed inclusion, this contains the error message.
  const char* content;
  size_t content_length;
  // User data to be passed along with this request.
  void* user_data;
};

// The kinds of include requests.
using shaderc_include_type = enum {
  shaderc_include_type_relative,  // E.g. #include "source"
  shaderc_include_type_standard   // E.g. #include <source>
};

using shaderc_include_resolve_fn = upcall shaderc_include_result* ShadercIncludeResolveFn(
    void* user_data, const char* requested_source, int type,
    const char* requesting_source, size_t include_depth);
using shaderc_include_result_release_fn = upcall void ShadercIncludeResultReleaseFn(
    void* user_data, shaderc_include_result* include_result);

fn void shaderc_compile_options_set_include_callbacks(
    shaderc_compile_options_t options, shaderc_include_resolve_fn resolver,
    shaderc_include_result_release_fn result_releaser, void* user_data);
fn void shaderc_compile_options_set_suppress_warnings(
    shaderc_compile_options_t options);
fn void shaderc_compile_options_set_target_env(
    shaderc_compile_options_t options,
    shaderc_target_env target,
    uint32_t version);
fn void shaderc_compile_options_set_target_spirv(
    shaderc_compile_options_t options, shaderc_spirv_version version);
fn void shaderc_compile_options_set_warnings_as_errors(
    shaderc_compile_options_t options);
fn void shaderc_compile_options_set_limit(
    shaderc_compile_options_t options, shaderc_limit limit, int value);
fn void shaderc_compile_options_set_auto_bind_uniforms(
    shaderc_compile_options_t options, bool auto_bind);
fn void shaderc_compile_options_set_auto_combined_image_sampler(
    shaderc_compile_options_t options, bool upgrade);
fn void shaderc_compile_options_set_hlsl_io_mapping(
    shaderc_compile_options_t options, bool hlsl_iomap);
fn void shaderc_compile_options_set_hlsl_offsets(
    shaderc_compile_options_t options, bool hlsl_offsets);
fn void shaderc_compile_options_set_binding_base(
    shaderc_compile_options_t options,
    shaderc_uniform_kind kind,
    uint32_t base);
fn void shaderc_compile_options_set_binding_base_for_stage(
    shaderc_compile_options_t options, shaderc_shader_kind shader_kind,
    shaderc_uniform_kind kind, uint32_t base);
fn void shaderc_compile_options_set_preserve_bindings(
    shaderc_compile_options_t options, bool preserve_bindings);
fn void shaderc_compile_options_set_max_id_bound(
    shaderc_compile_options_t options, uint32_t max_id_bound);
fn void shaderc_compile_options_set_auto_map_locations(
    shaderc_compile_options_t options, bool auto_map);
fn void shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage(
    shaderc_compile_options_t options, shaderc_shader_kind shader_kind,
    const char* reg, const char* set, const char* binding);
fn void shaderc_compile_options_set_hlsl_register_set_and_binding(
    shaderc_compile_options_t options, const char* reg, const char* set,
    const char* binding);
fn void shaderc_compile_options_set_hlsl_functionality1(
    shaderc_compile_options_t options, bool enable);
fn void shaderc_compile_options_set_hlsl_16bit_types(
    shaderc_compile_options_t options, bool enable);
fn void shaderc_compile_options_set_vulkan_rules_relaxed(
    shaderc_compile_options_t options, bool enable);
fn void shaderc_compile_options_set_invert_y(
    shaderc_compile_options_t options, bool enable);
fn void shaderc_compile_options_set_nan_clamp(
    shaderc_compile_options_t options, bool enable);

using shaderc_compilation_result_t = struct shaderc_compilation_result*;

fn shaderc_compilation_result_t shaderc_compile_into_spv(
    const shaderc_compiler_t compiler, const char* source_text,
    size_t source_text_size, shaderc_shader_kind shader_kind,
    const char* input_file_name, const char* entry_point_name,
    const shaderc_compile_options_t additional_options);
fn shaderc_compilation_result_t shaderc_compile_into_spv_assembly(
    const shaderc_compiler_t compiler, const char* source_text,
    size_t source_text_size, shaderc_shader_kind shader_kind,
    const char* input_file_name, const char* entry_point_name,
    const shaderc_compile_options_t additional_options);
fn shaderc_compilation_result_t shaderc_compile_into_preprocessed_text(
    const shaderc_compiler_t compiler, const char* source_text,
    size_t source_text_size, shaderc_shader_kind shader_kind,
    const char* input_file_name, const char* entry_point_name,
    const shaderc_compile_options_t additional_options);
fn shaderc_compilation_result_t shaderc_assemble_into_spv(
    const shaderc_compiler_t compiler, const char* source_assembly,
    size_t source_assembly_size,
    const shaderc_compile_options_t additional_options);

fn void shaderc_result_release(shaderc_compilation_result_t result);
fn size_t shaderc_result_get_length(const shaderc_compilation_result_t result);
fn size_t shaderc_result_get_num_warnings(
    const shaderc_compilation_result_t result);
fn size_t shaderc_result_get_num_errors(const shaderc_compilation_result_t result);
fn shaderc_compilation_status shaderc_result_get_compilation_status(
    const shaderc_compilation_result_t result);
fn const char* shaderc_result_get_bytes(const shaderc_compilation_result_t result);
fn const char* shaderc_result_get_error_message(
    const shaderc_compilation_result_t result);
fn void shaderc_get_spv_version(unsigned int* version, unsigned int* revision);
fn bool shaderc_parse_version_profile(const char* str, int* version,
    shaderc_profile* profile);
